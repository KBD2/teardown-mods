-- UMF Package umf_tool v0.10.0 generated with:
-- build.lua -n "umf_tool v0.10.0" -s dist/umf_tool.lua tool
--
local __RUNLATER = {} local UMF_RUNLATER = function(code) __RUNLATER[#__RUNLATER + 1] = code end
local __UMFLOADED = {["src/util/debug.lua"]=true,["src/core/hook.lua"]=true,["src/util/detouring.lua"]=true,["src/core/hooks_base.lua"]=true,["src/core/hooks_extra.lua"]=true,["src/util/registry.lua"]=true,["src/core/console_backend.lua"]=true,["src/core/_index.lua"]=true,["src/util/meta.lua"]=true,["src/vector/quat.lua"]=true,["src/vector/transform.lua"]=true,["src/vector/vector.lua"]=true,["src/entities/entity.lua"]=true,["src/entities/body.lua"]=true,["src/entities/joint.lua"]=true,["src/entities/light.lua"]=true,["src/entities/location.lua"]=true,["src/entities/player.lua"]=true,["src/entities/screen.lua"]=true,["src/entities/shape.lua"]=true,["src/entities/trigger.lua"]=true,["src/entities/vehicle.lua"]=true,["src/util/xml.lua"]=true,["src/animation/armature.lua"]=true,["src/tool/tool.lua"]=true,} local UMF_SOFTREQUIRE = function(name) return __UMFLOADED[name] end
(function() util = util or {} function util.current_line( level ) level = (level or 0) + 3 local _, line = pcall( error, "-", level ) if line == "-" then _, line = pcall( error, "-", level + 1 ) if line == "-" then return end line = "[C]:?" else line = line:sub( 1, -4 ) end return line end function util.stacktrace( start ) start = (start or 0) + 3 local stack, last = {}, nil for i = start, 32 do local _, line = pcall( error, "-", i ) if line == "-" then if last == "-" then break end else if last == "-" then stack[#stack + 1] = "[C]:?" end stack[#stack + 1] = line:sub( 1, -4 ) end last = line end return stack end end)();
(function() if hook then return end local hook_table = {} local hook_compiled = {} local function recompile( event ) local hooks = {} for k, v in pairs( hook_table[event] ) do hooks[#hooks + 1] = v end hook_compiled[event] = hooks end hook = { table = hook_table } function hook.add( event, identifier, func ) assert( type( event ) == "string", "Event must be a string" ) if func then assert( identifier ~= nil, "Identifier must not be nil" ) assert( type( func ) == "function", "Callback must be a function" ) else assert( type( identifier ) == "function", "Callback must be a function" ) end hook_table[event] = hook_table[event] or {} hook_table[event][identifier] = func or identifier recompile( event ) return identifier end function hook.remove( event, identifier ) assert( type( event ) == "string", "Event must be a string" ) assert( identifier ~= nil, "Identifier must not be nil" ) if hook_table[event] then hook_table[event][identifier] = nil if next( hook_table[event] ) == nil then hook_table[event] = nil hook_compiled[event] = nil else recompile( event ) end end end function hook.run( event, ... ) local hooks = hook_compiled[event] if not hooks then return end for i = 1, #hooks do local a, b, c, d, e = hooks[i]( ... ) if a ~= nil then return a, b, c, d, e end end end function hook.saferun( event, ... ) local hooks = hook_compiled[event] if not hooks then return end for i = 1, #hooks do local s, a, b, c, d, e = softassert( pcall( hooks[i], ... ) ) if s and a ~= nil then return a, b, c, d, e end end end function hook.saferun_debug( event, ... ) local hooks = hook_compiled[event] if not hooks then return end local args = { ... } for i = 1, #hooks do local s, a, b, c, d, e = xpcall( function() return hooks[i]( unpack( args ) ) end, function( err ) warning( err, 2 ) end ) if s and a ~= nil then return a, b, c, d, e end end end function hook.used( event ) return hook_table[event] end end)();
(function() if DETOUR then return end local original = {} local function call_original( name, ... ) local fn = original[name] if fn then return fn( ... ) end end local detoured = {} function DETOUR( name, generator ) original[name] = original[name] or rawget( _G, name ) detoured[name] = generator( function( ... ) return call_original( name, ... ) end ) rawset( _G, name, nil ) end setmetatable( _G, { __index = detoured, __newindex = function( self, k, v ) if detoured[k] then original[k] = v else rawset( self, k, v ) end end, } ) end)();
(function() UMF_RUNLATER "UpdateQuickloadPatch()" local hook = hook local function checkoriginal( b, ... ) if not b then printerror( ... ) return end return ... end local function simple_detour( name ) local event = "base." .. name DETOUR( name, function( original ) return function( ... ) hook.saferun( event, ... ) return checkoriginal( pcall( original, ... ) ) end end ) end local detours = { "init", "tick", "update", } for i = 1, #detours do simple_detour( detours[i] ) end function shoulddraw( kind ) return hook.saferun( "api.shoulddraw", kind ) ~= false end DETOUR( "draw", function( original ) return function( dt ) if shoulddraw( "all" ) then hook.saferun( "base.predraw", dt ) if shoulddraw( "original" ) then checkoriginal( pcall( original, dt ) ) end hook.saferun( "base.draw", dt ) end end end ) DETOUR( "Command", function( original ) return function( cmd, ... ) hook.saferun( "base.precmd", cmd, { ... } ) local a, b, c, d, e, f = original( cmd, ... ) hook.saferun( "base.postcmd", cmd, { ... }, { a, b, c, d, e, f } ) end end ) local saved = {} local function hasfunction( t, bck ) if bck[t] then return end bck[t] = true for k, v in pairs( t ) do if type( v ) == "function" then return true end if type( v ) == "table" and hasfunction( v, bck ) then return true end end end function UpdateQuickloadPatch() for k, v in pairs( _G ) do if k ~= "_G" and type( v ) == "table" and hasfunction( v, {} ) then saved[k] = v end end end local quickloadfix = function() for k, v in pairs( saved ) do _G[k] = v end end DETOUR( "handleCommand", function( original ) return function( command, ... ) if command == "quickload" then quickloadfix() end hook.saferun( "base.command." .. command, ... ) return original( command, ... ) end end ) hook.add( "base.tick", "api.firsttick", function() hook.remove( "base.tick", "api.firsttick" ) hook.saferun( "api.firsttick" ) if type( firsttick ) == "function" then firsttick() end end ) end)();
(function() function IsPlayerInVehicle() return GetBool( "game.player.usevehicle" ) end local tool = GetString( "game.player.tool" ) local invehicle = IsPlayerInVehicle() local keyboardkeys = { "esc", "up", "down", "left", "right", "space", "interact", "return" } for i = 97, 97 + 25 do keyboardkeys[#keyboardkeys + 1] = string.char( i ) end local function checkkeys( func, mousehook, keyhook ) if hook.used( keyhook ) and func( "any" ) then for i = 1, #keyboardkeys do if func( keyboardkeys[i] ) then hook.saferun( keyhook, keyboardkeys[i] ) end end end if hook.used( mousehook ) then if func( "lmb" ) then hook.saferun( mousehook, "lmb" ) end if func( "rmb" ) then hook.saferun( mousehook, "rmb" ) end end end local mousekeys = { "lmb", "rmb", "mmb" } local logicalinputs = { "up", "down", "left", "right", "interact", "flashlight", "jump", "crouch", "usetool", "grab", "handbrake", "map", "pause", "vehicleraise", "vehiclelower", "vehicleaction", "camerax", "cameray", } local heldkeys = {} hook.add( "base.tick", "api.default_hooks", function() if InputLastPressedKey then if hook.used( "api.mouse.pressed" ) or hook.used( "api.mouse.released" ) then for i = 1, #mousekeys do local k = mousekeys[i] if InputPressed( k ) then hook.saferun( "api.mouse.pressed", k ) elseif InputReleased( k ) then hook.saferun( "api.mouse.released", k ) end end end if hook.used( "api.input.pressed" ) or hook.used( "api.input.released" ) then for i = 1, #logicalinputs do local k = logicalinputs[i] if InputPressed( k ) then hook.saferun( "api.input.pressed", k ) elseif InputReleased( k ) then hook.saferun( "api.input.released", k ) end end end if hook.used( "api.key.pressed" ) or hook.used( "api.key.released" ) then local lastkey = InputLastPressedKey() if lastkey ~= "" then heldkeys[lastkey] = true hook.saferun( "api.key.pressed", lastkey ) end for key in pairs( heldkeys ) do if not InputDown( key ) then heldkeys[key] = nil hook.saferun( "api.key.released", key ) break end end end if hook.used( "api.mouse.wheel" ) then local wheel = InputValue( "mousewheel" ) if wheel ~= 0 then hook.saferun( "api.mouse.wheel", wheel ) end end if hook.used( "api.mouse.move" ) then local mousedx = InputValue( "mousedx" ) local mousedy = InputValue( "mousedy" ) if mousedx ~= 0 or mousedy ~= 0 then hook.saferun( "api.mouse.move", mousedx, mousedy ) end end if hook.used( "api.input.camera" ) then local camerax = InputValue( "camerax" ) local cameray = InputValue( "cameray" ) if camerax ~= 0 or cameray ~= 0 then hook.saferun( "api.input.camera", camerax, cameray ) end end elseif InputPressed then checkkeys( InputPressed, "api.mouse.pressed", "api.key.pressed" ) checkkeys( InputReleased, "api.mouse.released", "api.key.released" ) local wheel = InputValue( "mousewheel" ) if wheel ~= 0 then hook.saferun( "api.mouse.wheel", wheel ) end local mousedx = InputValue( "mousedx" ) local mousedy = InputValue( "mousedy" ) if mousedx ~= 0 or mousedy ~= 0 then hook.saferun( "api.mouse.move", mousedx, mousedy ) end end local n_invehicle = IsPlayerInVehicle() if invehicle ~= n_invehicle then hook.saferun( n_invehicle and "api.player.enter_vehicle" or "api.player.exit_vehicle", n_invehicle and GetPlayerVehicle() ) invehicle = n_invehicle end local n_tool = GetString( "game.player.tool" ) if tool ~= n_tool then hook.saferun( "api.player.switch_tool", n_tool, tool ) tool = n_tool end end ) end)();
(function() local coreloaded = UMF_SOFTREQUIRE "src/core/_index.lua" util = util or {} do local serialize_any, serialize_table serialize_table = function( val, bck ) if bck[val] then return "nil" end bck[val] = true local entries = {} for k, v in pairs( val ) do entries[#entries + 1] = string.format( "[%s] = %s", serialize_any( k, bck ), serialize_any( v, bck ) ) end return string.format( "{%s}", table.concat( entries, "," ) ) end serialize_any = function( val, bck ) local vtype = type( val ) if vtype == "table" then return serialize_table( val, bck ) elseif vtype == "string" then return string.format( "%q", val ) elseif vtype == "function" or vtype == "userdata" then return string.format( "nil ", tostring( val ) ) else return tostring( val ) end end function util.serialize( ... ) local result = {} for i = 1, select( "#", ... ) do result[i] = serialize_any( select( i, ... ), {} ) end return table.concat( result, "," ) end end function util.unserialize( dt ) local fn = loadstring( "return " .. dt ) if fn then setfenv( fn, {} ) return fn() end end do local function serialize_any( val, bck ) local vtype = type( val ) if vtype == "table" then if bck[val] then return "{}" end bck[val] = true local len = 0 for k, v in pairs( val ) do len = len + 1 end local rt = {} if len == #val then for i = 1, #val do rt[i] = serialize_any( val[i], bck ) end return string.format( "[%s]", table.concat( rt, "," ) ) else for k, v in pairs( val ) do if type( k ) == "string" or type( k ) == "number" then rt[#rt + 1] = string.format( "%s: %s", serialize_any( k, bck ), serialize_any( v, bck ) ) end end return string.format( "{%s}", table.concat( rt, "," ) ) end elseif vtype == "string" then return string.format( "%q", val ) elseif vtype == "function" or vtype == "userdata" or vtype == "nil" then return "null" else return tostring( val ) end end function util.serializeJSON( val ) return serialize_any( val, {} ) end end function util.shared_buffer( name, max ) max = max or 64 return { _pos_name = name .. ".position", _list_name = name .. ".list.", push = function( self, text ) local cpos = GetInt( self._pos_name ) SetString( self._list_name .. (cpos % max), text ) SetInt( self._pos_name, cpos + 1 ) end, len = function( self ) return math.min( GetInt( self._pos_name ), max ) end, pos = function( self ) return GetInt( self._pos_name ) end, get = function( self, index ) local pos = GetInt( self._pos_name ) local len = math.min( pos, max ) if index >= len then return end return GetString( self._list_name .. (pos + index - len) % max ) end, iterator = function( self ) local pos = GetInt( self._pos_name ) local len = math.min( pos, max ) return function( _, i ) i = (i or 0) + 1 if i >= len then return end return i, GetString( self._list_name .. (pos + i - len) % max ) end end, get_g = function( self, index ) return GetString( self._list_name .. (index % max) ) end, clear = function( self ) SetInt( self._pos_name, 0 ) ClearKey( self._list_name:sub( 1, -2 ) ) end, } end if coreloaded then function util.shared_channel( name, max, local_realm ) max = max or 64 local channel = { _buffer = util.shared_buffer( name, max ), _offset = 0, _hooks = {}, _ready_count = 0, _ready = {}, broadcast = function( self, ... ) return self:send( "", ... ) end, send = function( self, realm, ... ) self._buffer:push( string.format( ",%s,;%s", (type( realm ) == "table" and table.concat( realm, "," ) or tostring( realm )), util.serialize( ... ) ) ) end, listen = function( self, callback ) if self._ready[callback] ~= nil then return end self._hooks[#self._hooks + 1] = callback self:ready( callback ) return callback end, unlisten = function( self, callback ) self:unready( callback ) self._ready[callback] = nil for i = 1, #self._hooks do if self._hooks[i] == callback then table.remove( self._hooks, i ) return true end end end, ready = function( self, callback ) if not self._ready[callback] then self._ready_count = self._ready_count + 1 self._ready[callback] = true end end, unready = function( self, callback ) if self._ready[callback] then self._ready_count = self._ready_count - 1 self._ready[callback] = false end end, } local_realm = "," .. (local_realm or "unknown") .. "," local function receive( ... ) for i = 1, #channel._hooks do local f = channel._hooks[i] if channel._ready[f] then f( channel, ... ) end end end hook.add( "base.tick", name, function( dt ) if channel._ready_count > 0 then local last_pos = channel._buffer:pos() if last_pos > channel._offset then for i = math.max( channel._offset, last_pos - max ), last_pos - 1 do local message = channel._buffer:get_g( i ) local start = message:find( ";", 1, true ) local realms = message:sub( 1, start - 1 ) if realms == ",," or realms:find( local_realm, 1, true ) then receive( util.unserialize( message:sub( start + 1 ) ) ) if channel._ready_count <= 0 then channel._offset = i + 1 return end end end channel._offset = last_pos end end end ) return channel end function util.async_channel( channel ) local listener = { _channel = channel, _waiter = nil, read = function( self ) self._waiter = coroutine.running() if not self._waiter then error( "async_channel:read() can only be used in a coroutine" ) end self._channel:ready( self._handler ) return coroutine.yield() end, close = function( self ) if self._handler then self._channel:unlisten( self._handler ) end end, } listener._handler = listener._channel:listen( function( _, ... ) if listener._waiter then local co = listener._waiter listener._waiter = nil listener._channel:unready( listener._handler ) return coroutine.resume( co, ... ) end end ) listener._channel:unready( listener._handler ) return listener end end do local gets, sets = {}, {} function util.register_unserializer( type, callback ) gets[type] = function( key ) return callback( GetString( key ) ) end end if coreloaded then hook.add( "api.newmeta", "api.createunserializer", function( name, meta ) gets[name] = function( key ) return setmetatable( {}, meta ):__unserialize( GetString( key ) ) end sets[name] = function( key, value ) return SetString( key, meta.__serialize( value ) ) end end ) end function util.shared_table( name, base ) return setmetatable( base or {}, { __index = function( self, k ) local key = tostring( k ) local newtypekey = string.format( "%s.%s._type", name, key ) local newformat = HasKey( newtypekey ) local vtype = GetString( newformat and newtypekey or string.format( "%s.%s.type", name, key ) ) if vtype == "" then return end return gets[vtype]( string.format( newformat and "%s.%s" or "%s.%s.val", name, key ) ) end, __newindex = function( self, k, v ) local vtype = type( v ) local handler = sets[vtype] if not handler then return end local key = tostring( k ) if vtype == "table" then local meta = getmetatable( v ) if meta and meta.__serialize and meta.__type then vtype = meta.__type v = meta.__serialize( v ) handler = sets.string end end SetString( string.format( "%s.%s._type", name, key ), vtype ) handler( string.format( "%s.%s", name, key ), v ) end, } ) end function util.structured_table( name, base ) local function generate( base ) local root = {} local keys = {} for k, v in pairs( base ) do local key = name .. "." .. tostring( k ) if type( v ) == "table" then if #v == 0 then root[k] = util.structured_table( key, v ) else keys[k] = { type = v[1], key = key, default = v[2] } end elseif type( v ) == "string" then keys[k] = { type = v, key = key } else root[k] = v end end return setmetatable( root, { __index = function( self, k ) local entry = keys[k] if entry and gets[entry.type] then if HasKey( entry.key ) then return gets[entry.type]( entry.key ) else return entry.default end end end, __newindex = function( self, k, v ) local entry = keys[k] if entry and sets[entry.type] then if v == nil then ClearKey( entry.key ) else sets[entry.type]( entry.key, v ) end end end, } ) end if type( base ) == "table" then return generate( base ) end return generate end gets.number = GetFloat gets.integer = GetInt gets.boolean = GetBool gets.string = GetString gets.table = util.shared_table sets["nil"] = ClearKey sets.number = SetFloat sets.integer = SetInt sets.boolean = SetBool sets.string = SetString sets.table = function( key, val ) local tab = util.shared_table( key ) for k, v in pairs( val ) do tab[k] = v end end end end)();
(function() local console_buffer = util.shared_buffer( "game.console", 128 ) local function maketext( ... ) local text = "" local len = select( "#", ... ) for i = 1, len do local s = tostring( select( i, ... ) ) if i < len then s = s .. string.rep( " ", 8 - #s % 8 ) end text = text .. s end return text end _OLDPRINT = _OLDPRINT or print function printcolor( r, g, b, ... ) local text = maketext( ... ) console_buffer:push( string.format( "%f;%f;%f;%s", r, g, b, text ) ) if PRINTTOSCREEN then DebugPrint( text ) end return _OLDPRINT( ... ) end function print( ... ) printcolor( 1, 1, 1, ... ) end function printinfo( ... ) printcolor( 0, .6, 1, ... ) end function warning( msg, level ) printcolor( 1, .7, 0, "[WARNING] " .. tostring( msg ) .. "\n " .. table.concat( util.stacktrace( level or 1 ), "\n " ) ) end printwarning = warning function printerror( ... ) printcolor( 1, .2, 0, ... ) end function clearconsole() console_buffer:clear() end function softassert( b, ... ) if not b then printerror( ... ) end return b, ... end function assert( b, msg, ... ) if not b then local m = msg or "Assertion failed" warning( m ) return error( m, ... ) end return b, msg, ... end end)();
(function() GLOBAL_CHANNEL = util.shared_channel( "game.umf_global_channel", 128 ) end)();
(function() local coreloaded = UMF_SOFTREQUIRE "src/core/_index.lua" local registered_meta = {} local reverse_meta = {} function global_metatable( name, parent, usecomputed ) local meta = registered_meta[name] if meta then if not parent and not usecomputed then return meta end else meta = {} meta.__index = meta meta.__type = name registered_meta[name] = meta reverse_meta[meta] = name if coreloaded then hook.saferun( "api.newmeta", name, meta ) end end local newindex = rawset if usecomputed then local computed = {} meta._C = computed meta.__index = function( self, k ) local c = computed[k] if c then return c( self ) end return meta[k] end meta.__newindex = function( self, k, v ) local c = computed[k] if c then return c( self, true, v ) end return newindex( self, k, v ) end end if parent then local parent_meta = global_metatable( parent ) if parent_meta.__newindex then newindex = parent_meta.__newindex if not meta.__newindex then meta.__newindex = newindex end end setmetatable( meta, { __index = parent_meta.__index } ) end return meta end function find_global_metatable( name ) if not name then return end if type( name ) == "table" then return reverse_meta[name] end return registered_meta[name] end local function findmeta( src, found ) if found[src] then return end found[src] = true local res for k, v in pairs( src ) do if type( v ) == "table" then local dt local m = getmetatable( v ) if m then local name = reverse_meta[m] if name then dt = {} dt[1] = name end end local sub = findmeta( v, found ) if sub then dt = dt or {} dt[2] = sub end if dt then res = res or {} res[k] = dt end end end return res end function instantiate_global_metatable( name, base ) local t = base or {} t.__UMF_GLOBAL_METATYPE = name setmetatable( t, find_global_metatable( name ) ) return t end local function restoremeta( t, explored ) if explored[t] then return end explored[t] = true for _, v in pairs( t ) do if type( v ) == "table" then local meta_type = rawget( v, "__UMF_GLOBAL_METATYPE" ) if meta_type then setmetatable( v, global_metatable( meta_type ) ) end restoremeta( v, explored ) end end end function restore_global_metatables() restoremeta( _G, {} ) end if coreloaded then hook.add( "base.command.quickload", "api.metatables.restore", function() restore_global_metatables() end ) end end)();
(function() local vector_meta = global_metatable( "vector" ) local quat_meta quat_meta = global_metatable( "quaternion" ) function IsQuaternion( q ) return type( q ) == "table" and type( q[1] ) == "number" and type( q[2] ) == "number" and type( q[3] ) == "number" and type( q[4] ) == "number" end function MakeQuaternion( q ) return instantiate_global_metatable( "quaternion", q ) end function Quaternion( i, j, k, r ) if IsQuaternion( i ) then i, j, k, r = i[1], i[2], i[3], i[4] end return MakeQuaternion { i or 0, j or 0, k or 0, r or 1 } end function quat_meta:__unserialize( data ) local i, j, k, r = data:match( "([-0-9.]*);([-0-9.]*);([-0-9.]*);([-0-9.]*)" ) self[1] = tonumber( i ) self[2] = tonumber( j ) self[3] = tonumber( k ) self[4] = tonumber( r ) return self end function quat_meta:__serialize() return string.format("%f;%f;%f;%f", self[1], self[2], self[3], self[4]) end QUAT_ZERO = Quaternion() function quat_meta:Clone() return MakeQuaternion { self[1], self[2], self[3], self[4] } end local QuatStr = QuatStr function quat_meta:__tostring() return QuatStr( self ) end function quat_meta:__unm() return MakeQuaternion { -self[1], -self[2], -self[3], -self[4] } end function quat_meta:Conjugate() return MakeQuaternion { -self[1], -self[2], -self[3], self[4] } end function quat_meta:Invert() local l = quat_meta.LengthSquare( self ) return MakeQuaternion { -self[1] / l, -self[2] / l, -self[3] / l, self[4] / l } end function quat_meta:Add( o ) if IsQuaternion( o ) then self[1] = self[1] + o[1] self[2] = self[2] + o[2] self[3] = self[3] + o[3] self[4] = self[4] + o[4] else self[1] = self[1] + o self[2] = self[2] + o self[3] = self[3] + o self[4] = self[4] + o end return self end function quat_meta.__add( a, b ) if not IsQuaternion( a ) then a, b = b, a end return quat_meta.Add( quat_meta.Clone( a ), b ) end function quat_meta:Sub( o ) if IsQuaternion( o ) then self[1] = self[1] - o[1] self[2] = self[2] - o[2] self[3] = self[3] - o[3] self[4] = self[4] - o[4] else self[1] = self[1] - o self[2] = self[2] - o self[3] = self[3] - o self[4] = self[4] - o end return self end function quat_meta.__sub( a, b ) if not IsQuaternion( a ) then a, b = b, a end return quat_meta.Sub( quat_meta.Clone( a ), b ) end function quat_meta:Mul( o ) local i1, j1, k1, r1 = self[1], self[2], self[3], self[4] local i2, j2, k2, r2 = o[1], o[2], o[3], o[4] self[1] = j1 * k2 - k1 * j2 + r1 * i2 + i1 * r2 self[2] = k1 * i2 - i1 * k2 + r1 * j2 + j1 * r2 self[3] = i1 * j2 - j1 * i2 + r1 * k2 + k1 * r2 self[4] = r1 * r2 - i1 * i2 - j1 * j2 - k1 * k2 return self end function quat_meta.__mul( a, b ) if not IsQuaternion( a ) then a, b = b, a end if type( b ) == "number" then return Quaternion( a[1] * b, a[2] * b, a[3] * b, a[4] * b ) end if IsVector( b ) then return vector_meta.__mul( b, a ) end if IsTransformation( b ) then return Transformation( vector_meta.Mul( vector_meta.Clone( b.pos ), a ), QuatRotateQuat( b.rot, a ) ) end return MakeQuaternion( QuatRotateQuat( a, b ) ) end function quat_meta:Div( o ) if IsQuaternion( o ) then quat_meta.Mul( self, { -o[1], -o[2], -o[3], o[4] } ) else self[1] = self[1] / o self[2] = self[2] / o self[3] = self[3] / o self[4] = self[4] / o end return self end function quat_meta.__div( a, b ) return quat_meta.Div( quat_meta.Clone( a ), b ) end function quat_meta.__eq( a, b ) return a[1] == b[1] and a[2] == b[2] and a[3] == b[3] and a[4] == b[4] end function quat_meta:LengthSquare() return self[1] ^ 2 + self[2] ^ 2 + self[3] ^ 2 + self[4] ^ 2 end function quat_meta:Length() return math.sqrt( quat_meta.LengthSquare( self ) ) end local QuatSlerp = QuatSlerp function quat_meta:Slerp( o, n ) return MakeQuaternion( QuatSlerp( self, o, n ) ) end function quat_meta:Left() local x, y, z, s = self[1], self[2], self[3], self[4] return Vector( 1 - (y ^ 2 + z ^ 2) * 2, (z * s + x * y) * 2, (x * z - y * s) * 2 ) end function quat_meta:Up() local x, y, z, s = self[1], self[2], self[3], self[4] return Vector( (y * x - z * s) * 2, 1 - (z ^ 2 + x ^ 2) * 2, (x * s + y * z) * 2 ) end function quat_meta:Forward() local x, y, z, s = self[1], self[2], self[3], self[4] return Vector( (y * s + z * x) * 2, (z * y - x * s) * 2, 1 - (x ^ 2 + y ^ 2) * 2 ) end function quat_meta:ToEuler() if GetQuatEuler then return GetQuatEuler( self ) end local x, y, z, w = self[1], self[2], self[3], self[4] local bank, heading, attitude local s = 2 * x * y + 2 * z * w if s >= 1 then heading = 2 * math.atan2( x, w ) bank = 0 attitude = math.pi / 2 elseif s <= -1 then heading = -2 * math.atan2( x, w ) bank = 0 attitude = math.pi / -2 else bank = math.atan2( 2 * x * w - 2 * y * z, 1 - 2 * x ^ 2 - 2 * z ^ 2 ) heading = math.atan2( 2 * y * w - 2 * x * z, 1 - 2 * y ^ 2 - 2 * z ^ 2 ) attitude = math.asin( s ) end return math.deg( bank ), math.deg( heading ), math.deg( attitude ) end function quat_meta:ToAxisAngle() local iw = math.sqrt( 1 - self[4] ^ 2 ) if iw <= 0 then return Vector( 0, 0, 0 ), 0 end return Vector( self[1] / iw, self[2] / iw, self[3] / iw ), math.deg( math.asin( iw ) * 2 ) end function quat_meta:Approach( dest, rate ) local dot = self[1] * dest[1] + self[2] * dest[2] + self[3] * dest[3] + self[4] * dest[4] if dot >= 1 then return self end local corr_rate = rate / math.acos( 2 * dot ^ 2 - 1 ) if corr_rate >= 1 then return MakeQuaternion( dest ) end return MakeQuaternion( QuatSlerp( self, dest, corr_rate ) ) end end)();
(function() local vector_meta = global_metatable( "vector" ) local quat_meta = global_metatable( "quaternion" ) local transform_meta transform_meta = global_metatable( "transformation" ) function IsTransformation( t ) return type( t ) == "table" and t.pos and t.rot end function MakeTransformation( t ) instantiate_global_metatable( "vector", t.pos ) instantiate_global_metatable( "quaternion", t.rot ) return instantiate_global_metatable( "transformation", t ) end function Transformation( pos, rot ) return MakeTransformation { pos = pos, rot = rot } end function transform_meta:__unserialize( data ) local x, y, z, i, j, k, r = data:match( "([-0-9.]*);([-0-9.]*);([-0-9.]*);([-0-9.]*);([-0-9.]*);([-0-9.]*);([-0-9.]*)" ) self.pos = Vector( tonumber( x ), tonumber( y ), tonumber( z ) ) self.rot = Quaternion( tonumber( i ), tonumber( j ), tonumber( k ), tonumber( r ) ) return self end function transform_meta:__serialize() return string.format("%f;%f;%f;%f;%f;%f;%f", self.pos[1], self.pos[2], self.pos[3], self.rot[1], self.rot[2], self.rot[3], self.rot[4]) end function transform_meta:Clone() return MakeTransformation { pos = vector_meta.Clone( self.pos ), rot = quat_meta.Clone( self.rot ) } end local TransformStr = TransformStr function transform_meta:__tostring() return TransformStr( self ) end local TransformToLocalPoint = TransformToLocalPoint local TransformToLocalTransform = TransformToLocalTransform local TransformToLocalVec = TransformToLocalVec local TransformToParentPoint = TransformToParentPoint local TransformToParentTransform = TransformToParentTransform local TransformToParentVec = TransformToParentVec function transform_meta.__add( a, b ) if not IsTransformation( b ) then if IsVector( b ) then b = Transformation( b, QUAT_ZERO ) elseif IsQuaternion( b ) then b = Transformation( VEC_ZERO, b ) end end return MakeTransformation( TransformToParentTransform( a, b ) ) end function transform_meta:ToLocal( o ) if IsTransformation( o ) then return MakeTransformation( TransformToLocalTransform( self, o ) ) elseif IsQuaternion( o ) then return MakeQuaternion( TransformToLocalTransform( self, Transform( {}, o ) ).rot ) else return MakeVector( TransformToLocalPoint( self, o ) ) end end function transform_meta:ToLocalDir( o ) return MakeVector( TransformToLocalVec( self, o ) ) end function transform_meta:ToGlobal( o ) if IsTransformation( o ) then return MakeTransformation( TransformToParentTransform( self, o ) ) elseif IsQuaternion( o ) then return MakeQuaternion( TransformToParentTransform( self, Transform( {}, o ) ).rot ) else return MakeVector( TransformToParentPoint( self, o ) ) end end function transform_meta:ToGlobalDir( o ) return MakeVector( TransformToParentVec( self, o ) ) end function transform_meta:Raycast( dist, mul, radius, rejectTransparent ) local dir = TransformToParentVec( self, VEC_FORWARD ) if mul then vector_meta.Mul( dir, mul ) end local hit, dist2, normal, shape = QueryRaycast( self.pos, dir, dist, radius, rejectTransparent ) return { hit = hit, dist = dist2, normal = hit and MakeVector( normal ), shape = hit and Shape and Shape( shape ) or shape, hitpos = vector_meta.__add( self.pos, vector_meta.Mul( dir, hit and dist2 or dist ) ), } end end)();
(function() local quat_meta = global_metatable( "quaternion" ) local vector_meta vector_meta = global_metatable( "vector" ) function IsVector( v ) return type( v ) == "table" and type( v[1] ) == "number" and type( v[2] ) == "number" and type( v[3] ) == "number" and not v[4] end function MakeVector( v ) return instantiate_global_metatable( "vector", v ) end function Vector( x, y, z ) if IsVector( x ) then x, y, z = x[1], x[2], x[3] end return MakeVector { x or 0, y or 0, z or 0 } end function vector_meta:__unserialize( data ) local x, y, z = data:match( "([-0-9.]*);([-0-9.]*);([-0-9.]*)" ) self[1] = tonumber( x ) self[2] = tonumber( y ) self[3] = tonumber( z ) return self end function vector_meta:__serialize() return string.format("%f;%f;%f", self[1], self[2], self[3]) end VEC_ZERO = Vector() VEC_FORWARD = Vector( 0, 0, 1 ) VEC_UP = Vector( 0, 1, 0 ) VEC_LEFT = Vector( 1, 0, 0 ) function vector_meta:Clone() return MakeVector { self[1], self[2], self[3] } end local VecStr = VecStr function vector_meta:__tostring() return VecStr( self ) end function vector_meta:__unm() return MakeVector { -self[1], -self[2], -self[3] } end function vector_meta:Add( o ) if IsVector( o ) then self[1] = self[1] + o[1] self[2] = self[2] + o[2] self[3] = self[3] + o[3] else self[1] = self[1] + o self[2] = self[2] + o self[3] = self[3] + o end return self end function vector_meta.__add( a, b ) if not IsVector( a ) then a, b = b, a end if IsTransformation( b ) then return Transformation( vector_meta.Add( vector_meta.Clone( a ), b.pos ), quat_meta.Clone( b.rot ) ) end return vector_meta.Add( vector_meta.Clone( a ), b ) end function vector_meta:Sub( o ) if IsVector( o ) then self[1] = self[1] - o[1] self[2] = self[2] - o[2] self[3] = self[3] - o[3] else self[1] = self[1] - o self[2] = self[2] - o self[3] = self[3] - o end return self end function vector_meta.__sub( a, b ) if not IsVector( a ) then a, b = b, a end return vector_meta.Sub( vector_meta.Clone( a ), b ) end function vector_meta:Mul( o ) if IsVector( o ) then self[1] = self[1] * o[1] self[2] = self[2] * o[2] self[3] = self[3] * o[3] elseif IsQuaternion( o ) then local x1, y1, z1 = self[1], self[2], self[3] local x2, y2, z2, s = o[1], o[2], o[3], o[4] local x3 = y2 * z1 - z2 * y1 local y3 = z2 * x1 - x2 * z1 local z3 = x2 * y1 - y2 * x1 self[1] = x1 + (x3 * s + y2 * z3 - z2 * y3) * 2 self[2] = y1 + (y3 * s + z2 * x3 - x2 * z3) * 2 self[3] = z1 + (z3 * s + x2 * y3 - y2 * x3) * 2 else self[1] = self[1] * o self[2] = self[2] * o self[3] = self[3] * o end return self end function vector_meta.__mul( a, b ) if not IsVector( a ) then a, b = b, a end return vector_meta.Mul( vector_meta.Clone( a ), b ) end function vector_meta:Div( o ) self[1] = self[1] / o self[2] = self[2] / o self[3] = self[3] / o return self end function vector_meta.__div( a, b ) return vector_meta.Div( vector_meta.Clone( a ), b ) end function vector_meta:Mod( o ) self[1] = self[1] % o self[2] = self[2] % o self[3] = self[3] % o return self end function vector_meta.__mod( a, b ) return vector_meta.Mod( vector_meta.Clone( a ), b ) end function vector_meta:Pow( o ) self[1] = self[1] ^ o self[2] = self[2] ^ o self[3] = self[3] ^ o return self end function vector_meta.__pow( a, b ) return vector_meta.Pow( vector_meta.Clone( a ), b ) end function vector_meta.__eq( a, b ) return a[1] == b[1] and a[2] == b[2] and a[3] == b[3] end function vector_meta.__lt( a, b ) return a[1] < b[1] or (a[1] == b[1] and (a[2] < b[2] or (a[2] == b[2] and (a[3] < b[3])))) end function vector_meta.__le( a, b ) return a[1] < b[1] or (a[1] == b[1] and (a[2] < b[2] or (a[2] == b[2] and (a[3] <= b[3])))) end local VecDot = VecDot function vector_meta:Dot( b ) return VecDot( self, b ) end local VecCross = VecCross function vector_meta:Cross( b ) return MakeVector( VecCross( self, b ) ) end local VecLength = VecLength function vector_meta:Length() return VecLength( self ) end function vector_meta:Volume() return math.abs( self[1] * self[2] * self[3] ) end local VecLerp = VecLerp function vector_meta:Lerp( o, n ) return MakeVector( VecLerp( self, o, n ) ) end local VecNormalize = VecNormalize function vector_meta:Normalized() return MakeVector( VecNormalize( self ) ) end function vector_meta:Normalize() return vector_meta.Div( self, vector_meta.Length( self ) ) end function vector_meta:DistSquare( o ) return (self[1] - o[1]) ^ 2 + (self[2] - o[2]) ^ 2 + (self[3] - o[3]) ^ 2 end function vector_meta:Distance( o ) return math.sqrt( vector_meta.DistSquare( self, o ) ) end function vector_meta:LookAt( o ) return MakeQuaternion( QuatLookAt( self, o ) ) end function vector_meta:ToQuaternion( target_up ) local forward = VecScale( self, -1 / VecLength( self ) ) local right = VecNormalize( VecCross( target_up or Vec( 0, 1, 0 ), forward ) ) local up = VecCross( forward, right ) local m00, m01, m02 = right[1], right[2], right[3] local m10, m11, m12 = up[1], up[2], up[3] local m20, m21, m22 = forward[1], forward[2], forward[3] if m22 < 0 then if m00 > m11 then local t = 1 + m00 - m11 - m22 local t2 = 0.5 / math.sqrt( t ) return Quaternion( t2 * t, t2 * (m01 + m10), t2 * (m20 + m02), t2 * (m12 - m21) ) else local t = 1 - m00 + m11 - m22 local t2 = 0.5 / math.sqrt( t ) return Quaternion( t2 * (m01 + m10), t2 * t, t2 * (m12 + m21), t2 * (m20 - m02) ) end else if m00 < -m11 then local t = 1 - m00 - m11 + m22 local t2 = 0.5 / math.sqrt( t ) return Quaternion( t2 * (m20 + m02), t2 * (m12 + m21), t2 * t, t2 * (m01 - m10) ) else local t = 1 + m00 + m11 + m22 local t2 = 0.5 / math.sqrt( t ) return Quaternion( t2 * (m12 - m21), t2 * (m20 - m02), t2 * (m01 - m10), t2 * t ) end end end function vector_meta:Approach( dest, rate ) local dist = vector_meta.Distance( self, dest ) if dist < rate then return dest end return vector_meta.Lerp( self, dest, rate / dist ) end function vector_meta:Min( ... ) local n = vector_meta.Clone( self ) for i = 1, select( "#", ... ) do local o = select( i, ... ) if type( o ) == "number" then n[1] = math.min( n[1], o ) n[2] = math.min( n[2], o ) n[3] = math.min( n[3], o ) else n[1] = math.min( n[1], o[1] ) n[2] = math.min( n[2], o[2] ) n[3] = math.min( n[3], o[3] ) end end return n end function vector_meta:Max( ... ) local n = vector_meta.Clone( self ) for i = 1, select( "#", ... ) do local o = select( i, ... ) if type( o ) == "number" then n[1] = math.max( n[1], o ) n[2] = math.max( n[2], o ) n[3] = math.max( n[3], o ) else n[1] = math.max( n[1], o[1] ) n[2] = math.max( n[2], o[2] ) n[3] = math.max( n[3], o[3] ) end end return n end function vector_meta:Clamp( min, max ) if type( min ) == "number" then return Vector( math.max( math.min( self[1], max ), min ), math.max( math.min( self[2], max ), min ), math.max( math.min( self[3], max ), min ) ) else return Vector( math.max( math.min( self[1], max[1] ), min[1] ), math.max( math.min( self[2], max[2] ), min[2] ), math.max( math.min( self[3], max[3] ), min[3] ) ) end end end)();
(function() local entity_meta entity_meta = global_metatable( "entity" ) local properties = {} local DATA_KEY = {} local TAGS_KEY = {} function entity_meta:__index( k ) if properties[k] then return properties[k]( self, false ) end if entity_meta[k] then return entity_meta[k] end local entdata = rawget( self, DATA_KEY ) if not entdata then entdata = util.shared_table( "game.umf.entdata." .. self.handle ) rawset( self, DATA_KEY, entdata ) end return entdata[k] end function entity_meta:__newindex( k, v ) if properties[k] then return properties[k]( self, true, v ) end local entdata = rawget( self, DATA_KEY ) if not entdata then entdata = util.shared_table( "game.umf.entdata." .. self.handle ) rawset( self, DATA_KEY, entdata ) end entdata[k] = v end function properties:description( set, val ) if set then SetDescription( self.handle, val ) else return GetDescription( self.handle ) end end local tags_meta = { __index = function( self, k ) if HasTag( self.__handle, k ) then return GetTagValue( self.__handle, k ) end end, __newindex = function( self, k, v ) if v == nil then RemoveTag( self.__handle, k ) else SetTag( self.__handle, k, tostring( v ) ) end end } function properties:tags( set ) if set then error( "cannot set tags key" ) end local enttags = rawget( self, TAGS_KEY ) if not enttags then enttags = setmetatable( { __handle = self.handle }, tags_meta ) rawset( self, TAGS_KEY, enttags ) end return enttags end function GetEntityHandle( e ) if IsEntity( e ) then return e.handle end return e end function IsValid( e ) if type( e ) == "table" and e.IsValid then return e:IsValid() end return false end function IsEntity( e ) return type( e ) == "table" and type( e.handle ) == "number" end function Entity( handle ) if type( handle ) == "number" and handle > 0 then local type = GetEntityType and GetEntityType( handle ) return instantiate_global_metatable( type or "entity", { handle = handle, type = type or "unknown" } ) end return handle end function entity_meta:__unserialize( data ) self.handle = tonumber( data ) return self end function entity_meta:__serialize() return tostring( self.handle ) end function entity_meta:__tostring() return string.format( "Entity[%d]", self.handle ) end function entity_meta:GetType() return rawget( self, "type" ) or "unknown" end local IsHandleValid = IsHandleValid function entity_meta:IsValid() return IsHandleValid( self.handle ) end local SetTag = SetTag function entity_meta:SetTag( tag, value ) assert( self:IsValid() ) return SetTag( self.handle, tag, value ) end local SetDescription = SetDescription function entity_meta:SetDescription( description ) assert( self:IsValid() ) return SetDescription( self.handle, description ) end local RemoveTag = RemoveTag function entity_meta:RemoveTag( tag ) assert( self:IsValid() ) return RemoveTag( self.handle, tag ) end local HasTag = HasTag function entity_meta:HasTag( tag ) assert( self:IsValid() ) return HasTag( self.handle, tag ) end local GetTagValue = GetTagValue function entity_meta:GetTagValue( tag ) assert( self:IsValid() ) return GetTagValue( self.handle, tag ) end local GetDescription = GetDescription function entity_meta:GetDescription() assert( self:IsValid() ) return GetDescription( self.handle ) end local Delete = Delete function entity_meta:Delete() return Delete( self.handle ) end end)();
(function() local body_meta body_meta = global_metatable( "body", "entity", true ) function IsBody( e ) return IsEntity( e ) and e.type == "body" end function Body( handle ) if handle > 0 then return instantiate_global_metatable( "body", { handle = handle, type = "body" } ) end end function FindBodyByTag( tag, global ) return Body( FindBody( tag, global ) ) end function FindBodiesByTag( tag, global ) local t = FindBodies( tag, global ) for i = 1, #t do t[i] = Body( t[i] ) end return t end function body_meta:__tostring() return string.format( "Body[%d]", self.handle ) end function body_meta:ApplyImpulse( pos, vel ) assert( self:IsValid() ) return ApplyBodyImpulse( self.handle, pos, vel ) end function body_meta:ApplyLocalImpulse( pos, vel ) local transform = self:GetTransform() return self:ApplyImpulse( transform:ToGlobal( pos ), transform:ToGlobalDir( vel ) ) end function body_meta:DrawOutline( r, ... ) assert( self:IsValid() ) return DrawBodyOutline( self.handle, r, ... ) end function body_meta:DrawHighlight( amount ) assert( self:IsValid() ) return DrawBodyHighlight( self.handle, amount ) end function body_meta:SetTransform( tr ) assert( self:IsValid() ) return SetBodyTransform( self.handle, tr ) end function body_meta:SetActive( bool ) assert( self:IsValid() ) return SetBodyActive( self.handle, bool ) end function body_meta:SetDynamic( bool ) assert( self:IsValid() ) return SetBodyDynamic( self.handle, bool ) end function body_meta:SetVelocity( vel ) assert( self:IsValid() ) return SetBodyVelocity( self.handle, vel ) end function body_meta:SetAngularVelocity( avel ) assert( self:IsValid() ) return SetBodyAngularVelocity( self.handle, avel ) end function body_meta:GetTransform() assert( self:IsValid() ) return MakeTransformation( GetBodyTransform( self.handle ) ) end function body_meta:GetMass() assert( self:IsValid() ) return GetBodyMass( self.handle ) end function body_meta:GetVelocity() assert( self:IsValid() ) return MakeVector( GetBodyVelocity( self.handle ) ) end function body_meta:GetVelocityAtPos( pos ) assert( self:IsValid() ) return MakeVector( GetBodyVelocityAtPos( self.handle, pos ) ) end function body_meta:GetAngularVelocity() assert( self:IsValid() ) return MakeVector( GetBodyAngularVelocity( self.handle ) ) end function body_meta:GetShapes() assert( self:IsValid() ) local shapes = GetBodyShapes( self.handle ) for i = 1, #shapes do shapes[i] = Shape( shapes[i] ) end return shapes end function body_meta:GetVehicle() assert( self:IsValid() ) return Vehicle( GetBodyVehicle( self.handle ) ) end function body_meta:GetWorldBounds() assert( self:IsValid() ) local min, max = GetBodyBounds( self.handle ) return MakeVector( min ), MakeVector( max ) end function body_meta:GetLocalCenterOfMass() assert( self:IsValid() ) return MakeVector( GetBodyCenterOfMass( self.handle ) ) end function body_meta:GetWorldCenterOfMass() return self:GetTransform():ToGlobal( self:GetLocalCenterOfMass() ) end function body_meta:GetClosestPoint( origin ) local hit, point, normal, shape = GetBodyClosestPoint( self.handle, origin ) if not hit then return false end return hit, MakeVector( point ), MakeVector( normal ), Shape( shape ) end function body_meta:GetJointedBodies() local list = GetJointedBodies( self.handle ) for i = 1, #list do list[i] = Body( list[i] ) end return list end function body_meta:IsActive() assert( self:IsValid() ) return IsBodyActive( self.handle ) end function body_meta:IsDynamic() assert( self:IsValid() ) return IsBodyDynamic( self.handle ) end function body_meta:IsVisible( maxdist ) assert( self:IsValid() ) return IsBodyVisible( self.handle, maxdist ) end function body_meta:IsBroken() return not self:IsValid() or IsBodyBroken( self.handle ) end function body_meta:IsJointedToStatic() assert( self:IsValid() ) return IsBodyJointedToStatic( self.handle ) end function body_meta._C:transform( setter, val ) if setter then self:SetTransform( val ) else return self:GetTransform() end end function body_meta._C:velocity( setter, val ) if setter then self:SetVelocity( val ) else return self:GetVelocity() end end function body_meta._C:angularVelocity( setter, val ) if setter then self:SetVelocity( val ) else return self:GetVelocity() end end function body_meta._C:active( setter, val ) if setter then self:SetActive( val ) else return self:IsActive() end end function body_meta._C:dynamic( setter, val ) if setter then self:SetDynamic( val ) else return self:IsDynamic() end end function body_meta._C:broken( setter ) assert(not setter, "cannot set broken") return self:IsBroken() end function body_meta._C:mass( setter ) assert(not setter, "cannot set mass") return self:GetMass() end function body_meta._C:shapes( setter ) assert(not setter, "cannot set shapes") return self:GetShapes() end function body_meta._C:vehicle( setter ) assert(not setter, "cannot set vehicle") return self:GetVehicle() end end)();
(function() local joint_meta joint_meta = global_metatable( "joint", "entity", true ) function IsJoint( e ) return IsEntity( e ) and e.type == "joint" end function Joint( handle ) if handle > 0 then return instantiate_global_metatable( "joint", { handle = handle, type = "joint" } ) end end function FindJointByTag( tag, global ) return Joint( FindJoint( tag, global ) ) end function FindJointsByTag( tag, global ) local t = FindJoints( tag, global ) for i = 1, #t do t[i] = Joint( t[i] ) end return t end function joint_meta:__tostring() return string.format( "Joint[%d]", self.handle ) end function joint_meta:DetachFromShape( shape ) DetachJointFromShape( self.handle, GetEntityHandle( shape ) ) end function joint_meta:SetMotor( velocity, strength ) assert( self:IsValid() ) return SetJointMotor( self.handle, velocity, strength ) end function joint_meta:SetMotorTarget( target, maxVel, strength ) assert( self:IsValid() ) return SetJointMotorTarget( self.handle, target, maxVel, strength ) end function joint_meta:GetJointType() assert( self:IsValid() ) return GetJointType( self.handle ) end function joint_meta:GetOtherShape( shape ) assert( self:IsValid() ) return Shape( GetJointOtherShape( self.handle, GetEntityHandle( shape ) ) ) end function joint_meta:GetLimits() assert( self:IsValid() ) return GetJointLimits( self.handle ) end function joint_meta:GetMovement() assert( self:IsValid() ) return GetJointMovement( self.handle ) end function joint_meta:IsBroken() return not self:IsValid() or IsJointBroken( self.handle ) end function joint_meta._C:jointType( setter ) assert(not setter, "cannot set jointType") return self:GetType() end function joint_meta._C:broken( setter ) assert(not setter, "cannot set broken") return self:IsBroken() end end)();
(function() local light_meta light_meta = global_metatable( "light", "entity", true ) function IsLight( e ) return IsEntity( e ) and e.type == "light" end function Light( handle ) if handle > 0 then return instantiate_global_metatable( "light", { handle = handle, type = "light" } ) end end function FindLightByTag( tag, global ) return Light( FindLight( tag, global ) ) end function FindLightsByTag( tag, global ) local t = FindLights( tag, global ) for i = 1, #t do t[i] = Light( t[i] ) end return t end function light_meta:__tostring() return string.format( "Light[%d]", self.handle ) end function light_meta:SetEnabled( enabled ) assert( self:IsValid() ) return SetLightEnabled( self.handle, enabled ) end function light_meta:SetColor( r, g, b ) assert( self:IsValid() ) return SetLightColor( self.handle, r, g, b ) end function light_meta:SetIntensity( intensity ) assert( self:IsValid() ) return SetLightIntensity( self.handle, intensity ) end function light_meta:GetTransform() assert( self:IsValid() ) return MakeTransformation( GetLightTransform( self.handle ) ) end function light_meta:GetShape() assert( self:IsValid() ) return Shape( GetLightShape( self.handle ) ) end function light_meta:IsActive() assert( self:IsValid() ) return IsLightActive( self.handle ) end function light_meta:IsPointAffectedByLight( point ) assert( self:IsValid() ) return IsPointAffectedByLight( self.handle, point ) end function light_meta._C:enabled( setter, val ) if setter then self:SetEnabled( val ) else return self:IsActive() end end function light_meta._C:color( setter, val ) assert(setter, "cannot get color") return self:SetColor( val[1], val[2], val[3] ) end function light_meta._C:intensity( setter, val ) assert(setter, "cannot get intensity") return self:SetIntensity( val ) end function light_meta._C:transform( setter ) assert(not setter, "cannot set transform") return self:GetTransform() end function light_meta._C:shape( setter ) assert(not setter, "cannot set shape") return self:GetShape() end end)();
(function() local location_meta location_meta = global_metatable( "location", "entity", true ) function IsLocation( e ) return IsEntity( e ) and e.type == "location" end function Location( handle ) if handle > 0 then return instantiate_global_metatable( "location", { handle = handle, type = "location" } ) end end function FindLocationByTag( tag, global ) return Location( FindLocation( tag, global ) ) end function FindLocationsByTag( tag, global ) local t = FindLocations( tag, global ) for i = 1, #t do t[i] = Location( t[i] ) end return t end function location_meta:__tostring() return string.format( "Location[%d]", self.handle ) end function location_meta:GetTransform() assert( self:IsValid() ) return MakeTransformation( GetLocationTransform( self.handle ) ) end function location_meta._C:transform( setter ) assert(not setter, "cannot set transform") return self:GetTransform() end end)();
(function() local player_meta player_meta = global_metatable( "player" ) PLAYER = instantiate_global_metatable( "player" ) function player_meta:__unserialize( data ) return self end function player_meta:__serialize() return "" end function player_meta:__tostring() return string.format( "Player" ) end function player_meta:GetType() return "player" end function player_meta:Respawn() return RespawnPlayer() end function player_meta:ReleaseGrab() ReleasePlayerGrab() end function player_meta:SetTransform( transform, includePitch ) return SetPlayerTransform( transform, includePitch ) end function player_meta:SetCamera( transform ) return SetCameraTransform( transform ) end function player_meta:SetFov( degrees ) return SetCameraFov( degrees ) end function player_meta:SetDof( distance, amount ) return SetCameraDof( distance, amount ) end function player_meta:SetSpawnTransform( transform ) return SetPlayerSpawnTransform( transform ) end function player_meta:SetVehicle( handle ) return SetPlayerVehicle( GetEntityHandle( handle ) ) end function player_meta:SetVelocity( velocity ) return SetPlayerVelocity( velocity ) end function player_meta:SetScreen( handle ) return SetPlayerScreen( GetEntityHandle( handle ) ) end function player_meta:SetHealth( health ) return SetPlayerHealth( health ) end function player_meta:SetGroundVelocity(vel) SetPlayerGroundVelocity(vel) end function player_meta:GetTransform( includePitch ) return MakeTransformation( GetPlayerTransform( includePitch ) ) end function player_meta:GetPlayerCamera() return MakeTransformation( GetPlayerCameraTransform() ) end function player_meta:GetCamera() return MakeTransformation( GetCameraTransform() ) end function player_meta:GetVelocity() return MakeVector( GetPlayerVelocity() ) end function player_meta:GetVehicle() return Vehicle( GetPlayerVehicle() ) end function player_meta:GetGrabShape() return Shape( GetPlayerGrabShape() ) end function player_meta:GetGrabBody() return Body( GetPlayerGrabBody() ) end function player_meta:GetPickShape() return Shape( GetPlayerPickShape() ) end function player_meta:GetPickBody() return Body( GetPlayerPickBody() ) end function player_meta:GetInteractShape() return Shape( GetPlayerInteractShape() ) end function player_meta:GetInteractBody() return Body( GetPlayerInteractBody() ) end function player_meta:GetScreen() return Screen( GetPlayerScreen() ) end function player_meta:GetHealth() return GetPlayerHealth() end end)();
(function() local screen_meta screen_meta = global_metatable( "screen", "entity", true ) function IsScreen( e ) return IsEntity( e ) and e.type == "screen" end function Screen( handle ) if handle > 0 then return instantiate_global_metatable( "screen", { handle = handle, type = "screen" } ) end end function FindScreenByTag( tag, global ) return Screen( FindScreen( tag, global ) ) end function FindScreensByTag( tag, global ) local t = FindScreens( tag, global ) for i = 1, #t do t[i] = Screen( t[i] ) end return t end function screen_meta:__tostring() return string.format( "Screen[%d]", self.handle ) end function screen_meta:SetEnabled( enabled ) assert( self:IsValid() ) return SetScreenEnabled( self.handle, enabled ) end function screen_meta:GetShape() assert( self:IsValid() ) return Shape( GetScreenShape( self.handle ) ) end function screen_meta:IsEnabled() assert( self:IsValid() ) return IsScreenEnabled( self.handle ) end function screen_meta._C:enabled( setter, val ) if setter then self:SetEnabled( val ) else return self:IsEnabled() end end function screen_meta._C:shape( setter ) assert(not setter, "cannot set shape") return self:GetShape() end end)();
(function() local shape_meta shape_meta = global_metatable( "shape", "entity", true ) function IsShape( e ) return IsEntity( e ) and e.type == "shape" end function Shape( handle ) if handle > 0 then return instantiate_global_metatable( "shape", { handle = handle, type = "shape" } ) end end function FindShapeByTag( tag, global ) return Shape( FindShape( tag, global ) ) end function FindShapesByTag( tag, global ) local t = FindShapes( tag, global ) for i = 1, #t do t[i] = Shape( t[i] ) end return t end function shape_meta:__tostring() return string.format( "Shape[%d]", self.handle ) end function shape_meta:DrawOutline( r, ... ) assert( self:IsValid() ) return DrawShapeOutline( self.handle, r, ... ) end function shape_meta:DrawHighlight( amount ) assert( self:IsValid() ) return DrawShapeHighlight( self.handle, amount ) end function shape_meta:SetLocalTransform( transform ) assert( self:IsValid() ) return SetShapeLocalTransform( self.handle, transform ) end function shape_meta:SetEmissiveScale( scale ) assert( self:IsValid() ) return SetShapeEmissiveScale( self.handle, scale ) end function shape_meta:SetCollisionFilter( layer, mask ) SetShapeCollisionFilter( self.handle, layer or 1, mask or 255 ) end function shape_meta:GetLocalTransform() assert( self:IsValid() ) return MakeTransformation( GetShapeLocalTransform( self.handle ) ) end function shape_meta:GetWorldTransform() assert( self:IsValid() ) return MakeTransformation( GetShapeWorldTransform( self.handle ) ) end function shape_meta:GetBody() assert( self:IsValid() ) return Body( GetShapeBody( self.handle ) ) end function shape_meta:GetJoints() assert( self:IsValid() ) local joints = GetShapeJoints( self.handle ) for i = 1, #joints do joints[i] = Joint( joints[i] ) end return joints end function shape_meta:GetLights() assert( self:IsValid() ) local lights = GetShapeLights( self.handle ) for i = 1, #lights do lights[i] = Light( lights[i] ) end return lights end function shape_meta:GetWorldBounds() assert( self:IsValid() ) local min, max = GetShapeBounds( self.handle ) return MakeVector( min ), MakeVector( max ) end function shape_meta:GetMaterialAtPos( pos ) assert( self:IsValid() ) return GetShapeMaterialAtPosition( self.handle, pos ) end function shape_meta:GetSize() assert( self:IsValid() ) return GetShapeSize( self.handle ) end function shape_meta:GetVoxelCount() assert( self:IsValid() ) return GetShapeVoxelCount( self.handle ) end function shape_meta:GetClosestPoint( origin ) local hit, point, normal = GetShapeClosestPoint( self.handle, origin ) if not hit then return false end return hit, MakeVector( point ), MakeVector( normal ) end function shape_meta:GetTouching() local min, max = self:GetWorldBounds() local potential = QueryAabbShapes( min - { 0.1, 0.1, 0.1 }, max + { 0.1, 0.1, 0.1 } ) local found = {} for i = 1, #potential do if potential[i] ~= self.handle and self:IsTouching( potential[i] ) then found[#found+1] = Shape( potential[i] ) end end return found end function shape_meta:IsVisible( maxDist, rejectTransparent ) assert( self:IsValid() ) return IsShapeVisible( self.handle, maxDist, rejectTransparent ) end function shape_meta:IsBroken() return not self:IsValid() or IsShapeBroken( self.handle ) end function shape_meta:IsTouching( shape ) assert( self:IsValid() ) return IsShapeTouching( self.handle, GetEntityHandle( shape ) ) end function shape_meta._C:transform( setter, val ) if setter then self:SetLocalTransform( val ) else return self:GetLocalTransform() end end function shape_meta._C:emissive( setter, val ) assert(setter, "cannot get emissive") self:SetEmissiveScale( val ) end function shape_meta._C:body( setter ) assert(not setter, "cannot set body") return self:GetBody() end function shape_meta._C:joints( setter ) assert(not setter, "cannot set joints") return self:GetJoints() end function shape_meta._C:lights( setter ) assert(not setter, "cannot set lights") return self:GetLights() end function shape_meta._C:size( setter ) assert(not setter, "cannot set size") return Vector( self:GetSize() ) end function shape_meta._C:broken( setter ) assert(not setter, "cannot set broken") return self:IsBroken() end end)();
(function() local trigger_meta trigger_meta = global_metatable( "trigger", "entity", true ) function IsTrigger( e ) return IsEntity( e ) and e.type == "trigger" end function Trigger( handle ) if handle > 0 then return instantiate_global_metatable( "trigger", { handle = handle, type = "trigger" } ) end end function FindTriggerByTag( tag, global ) return Trigger( FindTrigger( tag, global ) ) end function FindTriggersByTag( tag, global ) local t = FindTriggers( tag, global ) for i = 1, #t do t[i] = Trigger( t[i] ) end return t end function trigger_meta:__tostring() return string.format( "Trigger[%d]", self.handle ) end function trigger_meta:SetTransform( transform ) assert( self:IsValid() ) return SetTriggerTransform( self.handle, transform ) end function trigger_meta:GetTransform() assert( self:IsValid() ) return MakeTransformation( GetTriggerTransform( self.handle ) ) end function trigger_meta:GetDistance(origin) return GetTriggerDistance(self.handle, origin) end function trigger_meta:GetClosestPoint(origin) return MakeVector(GetTriggerDistance(self.handle, origin)) end function trigger_meta:GetWorldBounds() assert( self:IsValid() ) local min, max = GetTriggerBounds( self.handle ) return MakeVector( min ), MakeVector( max ) end function trigger_meta:IsBodyInTrigger( handle ) assert( self:IsValid() ) return IsBodyInTrigger( self.handle, GetEntityHandle( handle ) ) end function trigger_meta:IsVehicleInTrigger( handle ) assert( self:IsValid() ) return IsVehicleInTrigger( self.handle, GetEntityHandle( handle ) ) end function trigger_meta:IsShapeInTrigger( handle ) assert( self:IsValid() ) return IsShapeInTrigger( self.handle, GetEntityHandle( handle ) ) end function trigger_meta:IsPointInTrigger( point ) assert( self:IsValid() ) return IsPointInTrigger( self.handle, point ) end function trigger_meta:IsEmpty( demolision ) assert( self:IsValid() ) local empty, highpoint = IsTriggerEmpty( self.handle, demolision ) return empty, highpoint and MakeVector( highpoint ) end function trigger_meta._C:transform( setter, val ) if setter then self:SetTransform( val ) else return self:GetTransform() end end end)();
(function() local vehicle_meta vehicle_meta = global_metatable( "vehicle", "entity", true ) function IsVehicle( e ) return IsEntity( e ) and e.type == "vehicle" end function Vehicle( handle ) if handle > 0 then return instantiate_global_metatable( "vehicle", { handle = handle, type = "vehicle" } ) end end function FindVehicleByTag( tag, global ) return Vehicle( FindVehicle( tag, global ) ) end function FindVehiclesByTag( tag, global ) local t = FindVehicles( tag, global ) for i = 1, #t do t[i] = Vehicle( t[i] ) end return t end function vehicle_meta:__tostring() return string.format( "Vehicle[%d]", self.handle ) end function vehicle_meta:Drive( drive, steering, handbrake ) assert( self:IsValid() ) return DriveVehicle( self.handle, drive, steering, handbrake ) end function vehicle_meta:GetTransform() assert( self:IsValid() ) return MakeTransformation( GetVehicleTransform( self.handle ) ) end function vehicle_meta:GetBody() assert( self:IsValid() ) return Body( GetVehicleBody( self.handle ) ) end function vehicle_meta:GetHealth() assert( self:IsValid() ) return GetVehicleHealth( self.handle ) end function vehicle_meta:GetDriverPos() assert( self:IsValid() ) return MakeVector( GetVehicleDriverPos( self.handle ) ) end function vehicle_meta:GetGlobalDriverPos() return self:GetTransform():ToGlobal( self:GetDriverPos() ) end function vehicle_meta._C:transform( setter, val ) if setter then self:SetTransform( val ) else return self:GetTransform() end end function vehicle_meta._C:body( setter ) assert(not setter, "cannot set body") return self:GetBody() end function vehicle_meta._C:health( setter ) assert(not setter, "cannot set health") return self:GetHealth() end end)();
(function() local xml_meta xml_meta = global_metatable( "xmlnode" ) XMLTag = function( type ) return function( attributes ) return instantiate_global_metatable( "xmlnode", { type = type, attributes = attributes } ) end end ParseXML = function( xml ) local pos = 1 local function skipw() local next = xml:find( "[^ \t\n]", pos ) if not next then return false end pos = next return true end local function expect( pattern, noskip ) if not noskip then if not skipw() then return false end end local s, e = xml:find( pattern, pos ) if not s then return false end local pre = pos pos = e + 1 return xml:match( pattern, pre ) end local readtag, readattribute, readstring local rt = { n = "\n", t = "\t", r = "\r", ["0"] = "\0", ["\\"] = "\\", ["\""] = "\"" } readstring = function() if not expect( "^\"" ) then return false end local start = pos while true do local s = assert( xml:find( "[\\\"]", pos ), "Invalid string" ) if xml:sub( s, s ) == "\\" then pos = s + 2 else pos = s + 1 break end end return xml:sub( start, pos - 2 ):gsub( "\\(.)", rt ) end readattribute = function() local name = expect( "^([%d%w_]+)" ) if not name then return false end if expect( "^=" ) then return name, assert( readstring() ) else return name, "1" end end readtag = function() local save = pos if not expect( "^<" ) then return false end local type = expect( "^([%d%w_]+)" ) if not type then pos = save return false end skipw() local attributes = {} repeat local attr, val = readattribute() if attr then attributes[attr] = val end until not attr local children = {} if not expect( "^/>" ) then assert( expect( "^>" ) ) repeat local child = readtag() if child then children[#children + 1] = child end until not child assert( expect( "^</" ) and expect( "^" .. type ) and expect( "^>" ) ) end return XMLTag( type )( attributes )( children ) end return readtag() end function xml_meta:__call( children ) self.children = children return self end function xml_meta:Render() local attr = "" if self.attributes then for name, val in pairs( self.attributes ) do attr = string.format( "%s %s=%q", attr, name, val ) end end local children = {} if self.children then for i = 1, #self.children do children[i] = self.children[i]:Render() end end return string.format( "<%s%s>%s</%s>", self.type, attr, table.concat( children, "" ), self.type ) end end)();
(function() local armature_meta armature_meta = global_metatable( "armature" ) function LoadArmatureFromXML( xml, parts, scale ) scale = scale or 1 local dt = ParseXML( xml ) assert( (dt.type == "prefab" and dt.children[1] and dt.children[1].type == "group") or dt.type == "group", "Invalid Tool XML" ) local shapes = {} local offsets = {} for i = 1, #parts do shapes[i] = parts[i][1] local v = parts[i][2] offsets[parts[i][1]] = Vec( math.floor( v[1] / 2 ) / 10, 0, -math.floor( v[2] / 2 ) / 10 ) end local function parseVec( str ) if not str then return Vec( 0, 0, 0 ) end local x, y, z = str:match( "([%d.-]+) ([%d.-]+) ([%d.-]+)" ) return Vec( tonumber( x ), tonumber( y ), tonumber( z ) ) end local function parseTransform( attr ) local pos, angv = parseVec( attr.pos ), parseVec( attr.rot ) return Transform( Vec( pos[1], pos[2], pos[3] ), QuatEuler( angv[1], angv[2], angv[3] ) ) end local function translatebone( node, isLocation ) local t = { name = node.attributes.name, transform = parseTransform( node.attributes ) } local sub = t if not isLocation then t.name = "__FIXED_" .. node.attributes.name t[1] = { name = node.attributes.name } sub = t[1] end sub.shapes = {} for i = 1, #node.children do local child = node.children[i] if child.type == "vox" then local name = child.attributes.object local tr = parseTransform( child.attributes ) local s = child.attributes.scale and tonumber( child.attributes.scale ) or 1 sub.shapes[name] = TransformToParentTransform( tr, Transform( VecScale( offsets[name], -s ), QuatEuler( -90, 0, 0 ) ) ) elseif child.type == "group" then sub[#sub + 1] = translatebone( child ) elseif child.type == "location" then sub[#sub + 1] = translatebone( child, true ) end end return t end local bones = translatebone( dt.type == "prefab" and dt.children[1] or dt )[1] bones.transform = Transform( Vec(), QuatEuler( 0, 0, 0 ) ) bones.name = "root" local arm = Armature { shapes = shapes, scale = scale, bones = bones } arm:ComputeBones() return arm, dt end function Armature( definition ) local ids = {} for i, name in ipairs( definition.shapes ) do ids[name] = #definition.shapes - i + 1 end local armature = { root = definition.bones, refs = {}, scale = definition.scale, __noquickload = function() end, dirty = true, } local function dobone( b ) if b.name then armature.refs[b.name] = b end b.transform = b.transform or Transform() b.shape_offsets = {} b.dirty = true if b.shapes then for name, transform in pairs( b.shapes ) do table.insert( b.shape_offsets, { id = ids[name], tr = Transform( VecScale( transform.pos, definition.scale or 1 ), transform.rot ) } ) end end b.children = {} for i = 1, #b do b.children[i] = dobone( b[i] ) end return b end dobone( armature.root ) return instantiate_global_metatable( "armature", armature ) end local function computebone( bone, transform, scale, dirty ) dirty = dirty or bone.dirty or bone.jiggle_transform if dirty or not bone.gr_transform then bone.gr_transform = TransformToParentTransform( transform, bone.transform ) if bone.jiggle_transform then bone.gr_transform = TransformToParentTransform( bone.gr_transform, bone.jiggle_transform ) end bone.g_transform = Transform( VecScale( bone.gr_transform.pos, scale ), bone.gr_transform.rot ) bone.dirty = false end for i = 1, #bone.children do computebone( bone.children[i], bone.gr_transform, scale, dirty ) end end function armature_meta:ComputeBones() computebone( self.root, Transform(), self.scale or 1 ) self.dirty = false end local function applybone( shapes, bone ) for i = 1, #bone.shape_offsets do local offset = bone.shape_offsets[i] SetShapeLocalTransform( GetEntityHandle and GetEntityHandle( shapes[offset.id] ) or shapes[offset.id], TransformToParentTransform( bone.g_transform, offset.tr ) ) end for i = 1, #bone.children do applybone( shapes, bone.children[i] ) end end function armature_meta:Apply( shapes ) if self.dirty or self.jiggle then self:ComputeBones() end applybone( shapes, self.root ) end function armature_meta:SetBoneTransform( bone, transform ) local b = self.refs[bone] if not b then return end self.dirty = true b.dirty = true b.transform = transform end function armature_meta:GetBoneTransform( bone ) local b = self.refs[bone] if not b then return Transform() end return b.transform end function armature_meta:GetBoneGlobalTransform( bone ) local b = self.refs[bone] if not b then return Transform() end if self.dirty then self:ComputeBones() end return b.g_transform end function armature_meta:SetBoneJiggle( bone, jiggle, constraint ) local b = self.refs[bone] if not b then return end self.dirty = true if jiggle > 0 then self.jiggle = true end b.jiggle = math.atan( jiggle ) / math.pi * 2 b.jiggle_constraint = constraint end function armature_meta:GetBoneJiggle( bone ) local b = self.refs[bone] if not b then return 0 end return b.jiggle, b.jiggle_constraint end function armature_meta:ResetJiggle() for _, b in pairs( self.refs ) do b.jiggle_transform = nil end self.dirty = true end local function updatebone( bone, current_transform, prev_transform, dt, gravity ) local current_transform_local = TransformToParentTransform( current_transform, bone.transform ) local prev_transform_local = TransformToParentTransform( prev_transform, bone.old_transform or bone.transform ) bone.old_transform = bone.transform if bone.jiggle then prev_transform_local = TransformToParentTransform( prev_transform_local, bone.jiggle_transform or Transform() ) local local_diff = TransformToLocalTransform( current_transform_local, prev_transform_local ) local target = TransformToParentPoint( local_diff, Vec( 0, 0, -2 / dt ) ) if bone.jiggle_constraint and bone.jiggle_constraint.gravity then target = VecAdd( target, TransformToLocalVec( current_transform_local, VecScale( gravity, bone.jiggle_constraint.gravity ) ) ) end local lookat = QuatLookAt( Vec(), target ) bone.jiggle_transform = Transform( Vec(), QuatSlerp( lookat, QuatEuler( 0, 0, 0 ), 1 - bone.jiggle ) ) current_transform_local = TransformToParentTransform( current_transform_local, bone.jiggle_transform ) end for i = 1, #bone.children do updatebone( bone.children[i], current_transform_local, prev_transform_local, dt, gravity ) end end function armature_meta:UpdatePhysics( diff, dt, gravity ) dt = dt or 0.01666 diff.pos = VecScale( diff.pos, 1 / dt ) updatebone( self.root, Transform(), diff, dt, gravity or Vec( 0, -10, 0 ) ) end local function DebugAxis( tr, s ) s = s or 1 DebugLine( tr.pos, TransformToParentPoint( tr, Vec( 1 * s, 0, 0 ) ), 1, 0, 0 ) DebugLine( tr.pos, TransformToParentPoint( tr, Vec( 0, 1 * s, 0 ) ), 0, 1, 0 ) DebugLine( tr.pos, TransformToParentPoint( tr, Vec( 0, 0, 1 * s ) ), 0, 0, 1 ) end function armature_meta:DrawDebug( transform ) transform = transform or Transform() DebugAxis( transform, 0.05 ) for k, v in pairs( self.refs ) do local r = TransformToParentTransform( transform, v.g_transform ) local g = v.name:find( "^__FIXED_" ) and 1 or 0 for i = 1, #v.children do DebugLine( r.pos, TransformToParentTransform( transform, v.children[i].g_transform ).pos, 1, 1 - g, g, .4 ) end for i = 1, #v.shape_offsets do local offset = v.shape_offsets[i] local p = TransformToParentTransform( transform, TransformToParentTransform( v.g_transform, offset.tr ) ) DebugAxis( p, 0.03 ) DebugLine( r.pos, p.pos, 0, 1, 1, .4 ) end end end end)();
(function() local tool_meta tool_meta = global_metatable( "tool", nil, true ) local extra_tools = {} local alreadyInit = false function RegisterToolUMF( id, data, force ) if LoadArmatureFromXML and type( data.model ) == "table" then local arm, xml = LoadArmatureFromXML( data.model.prefab, data.model.objects, data.model.scale ) data.armature = arm data._ARMATURE = arm data._OBJECTS = data.model.objects local function findvox( xml ) if xml.type == "vox" then return xml.attributes["file"] end for i, c in ipairs( xml.children ) do local t = findvox( c ) if t then return t end end end data.model = data.model.path or findvox( xml ) end instantiate_global_metatable( "tool", data ) data.id = id extra_tools[id] = data if not data.group and HasKey( "game.tool." .. id .. ".skin.group" ) then data.group = GetInt( "game.tool." .. id .. ".skin.group" ) end if alreadyInit or force then if not data.noregister and not GetBool( "game.tool." .. id .. ".enabled" ) then RegisterTool( id, data.printname or id, data.model or "", data.group or 6 ) SetBool( "game.tool." .. id .. ".enabled", true ) end end for k, f in pairs( tool_meta._C ) do local v = rawget( data, k ) if v ~= nil then rawset( data, k, nil ) f( data, v ) end end return data end hook.add( "base.init", "api.tool_loader", function() for id, tool in pairs( extra_tools ) do if not tool.noregister and not GetBool( "game.tool." .. id .. ".enabled" ) then RegisterTool( id, tool.printname or id, tool.model or "", tool.group or 6 ) SetBool( "game.tool." .. id .. ".enabled", true ) end end alreadyInit = true end ) function tool_meta._C:ammo( setter, val ) local key = "game.tool." .. self.id .. ".ammo" local keystr = key .. ".display" if setter then if type( val ) == "number" then SetFloat( key, val ) ClearKey( keystr ) rawset( self, "_TOOLAMMOSTRING", false ) else SetFloat( key, 0 ) SetString( key .. ".display", tostring( val or "" ) ) rawset( self, "_TOOLAMMOSTRING", tostring( val or "" ) ) end elseif HasKey( keystr ) then return GetString( keystr ) else return GetFloat( key ) end end function tool_meta._C:enabled( setter, val ) local key = "game.tool." .. self.id .. ".enabled" if setter then SetBool( key, val ) else return GetBool( key ) end end function tool_meta:DrawInWorld( transform ) SetToolTransform( TransformToLocalTransform( GetCameraTransform(), transform ) ) end function tool_meta:GetTransform() return self._TRANSFORM or MakeTransformation( GetBodyTransform( GetToolBody() ) ) end function tool_meta:GetPredictedTransform() return self._TRANSFORM_FIX or MakeTransformation( GetBodyTransform( GetToolBody() ) ) end function tool_meta:GetTransformDelta() return self._TRANSFORM_DIFF or Transformation( Vec(), Quat() ) end function tool_meta:GetBoneGlobalTransform( bone, nopredicted ) if not self._ARMATURE then return Transformation( Vec(), Quat() ) end return (nopredicted and self:GetTransform() or self:GetPredictedTransform()):ToGlobal( self._ARMATURE:GetBoneGlobalTransform( bone ) ) end function tool_meta:DrawDebug( nobones, nobounds, nopredicted ) if not self._ARMATURE or not self._SHAPES then return end local ptr = (nopredicted and self:GetTransform() or self:GetPredictedTransform()) if not nobones and self._ARMATURE then self._ARMATURE:DrawDebug( ptr ) end if not nobounds and self._OBJECTS then local s = self._OBJECTS for i = 1, #self._SHAPES do visual.drawbox( ptr:ToGlobal( self._SHAPES[i]:GetLocalTransform() ), Vec( 0, 0, 0 ), VecScale( s[#s + 1 - i][2], .05 ), { r = 1, g = 1, b = 1, a = .2, writeZ = false } ) end end end function tool_meta:Initialize() end function tool_meta:Tick( dt ) end function tool_meta:Draw( dt ) end function tool_meta:Animate( body, shapes ) end function tool_meta:Deploy() end function tool_meta:Holster() end local function istoolactive() return GetBool( "game.player.canusetool" ) end local prev hook.add( "api.mouse.wheel", "api.tool_loader", function( ds ) if not istoolactive() then return end local tool = prev and extra_tools[prev] if tool and tool.MouseWheel then tool:MouseWheel( ds ) end end ) hook.add( "base.update", "api.tool_loader", function( dt ) local cur = GetString( "game.player.tool" ) local tool = extra_tools[cur] if tool then if tool.Update then softassert( pcall( tool.Update, tool, dt ) ) end end end ) hook.add( "base.tick", "api.tool_loader", function( dt ) local cur = GetString( "game.player.tool" ) local prevtool = prev and extra_tools[prev] if prevtool then if prevtool.ShouldLockMouseWheel then local s, b = softassert( pcall( prevtool.ShouldLockMouseWheel, prevtool ) ) if s then SetBool( "game.input.locktool", not not b ) end if b then SetString( "game.player.tool", prev ) cur = prev end end if prev ~= cur and prevtool.Holster then softassert( pcall( prevtool.Holster, prevtool ) ) end end local tool = extra_tools[cur] if tool then if prev ~= cur then if tool.Deploy then softassert( pcall( tool.Deploy, tool ) ) end if tool._ARMATURE then tool._ARMATURE:ResetJiggle() end end local body = GetToolBody() if not tool._BODY or tool._BODY.handle ~= body then tool._BODY = Body( body ) tool._SHAPES = tool._BODY and tool._BODY:GetShapes() end if tool._BODY then tool._TRANSFORM = tool._BODY:GetTransform() tool._TRANSFORM_DIFF = tool._TRANSFORM_OLD and tool._TRANSFORM:ToLocal( tool._TRANSFORM_OLD ) or Transformation( Vec(), Quat() ) local reverse_diff = tool._TRANSFORM_OLD and tool._TRANSFORM_OLD:ToLocal( tool._TRANSFORM ) or Transformation( Vec(), Quat() ) tool._TRANSFORM_FIX = tool._TRANSFORM:ToGlobal( reverse_diff ) if tool.Animate then softassert( pcall( tool.Animate, tool, tool._BODY, tool._SHAPES ) ) end if tool._ARMATURE then tool._ARMATURE:UpdatePhysics( tool:GetTransformDelta(), GetTimeStep(), TransformToLocalVec( tool:GetTransform(), Vec( 0, -10, 0 ) ) ) tool._ARMATURE:Apply( tool._SHAPES ) end end if tool._TOOLAMMOSTRING then SetInt( "game.tool." .. tool.id .. ".ammo", 0 ) end if tool.Tick then softassert( pcall( tool.Tick, tool, dt ) ) end if tool._TRANSFORM then tool._TRANSFORM_OLD = tool._TRANSFORM end end prev = cur end ) hook.add( "api.firsttick", "api.tool_loader", function() for id, tool in pairs( extra_tools ) do if tool.Initialize then softassert( pcall( tool.Initialize, tool ) ) end end end ) hook.add( "base.draw", "api.tool_loader", function( dt ) local tool = extra_tools[GetString( "game.player.tool" )] if tool and tool.Draw then softassert( pcall( tool.Draw, tool, dt ) ) end end ) hook.add( "api.mouse.pressed", "api.tool_loader", function( button ) local tool = extra_tools[GetString( "game.player.tool" )] local event = button == "lmb" and "LeftClick" or button == "rmb" and "RightClick" if tool and istoolactive() then if event and tool[event] then softassert( pcall( tool[event], tool ) ) end if tool.MousePressed then softassert( pcall( tool.MousePressed, tool, button ) ) end end end ) hook.add( "api.mouse.released", "api.tool_loader", function( button ) local tool = extra_tools[GetString( "game.player.tool" )] local event = button == "lmb" and "LeftClickReleased" or button == "rmb" and "RightClickReleased" if tool and istoolactive() then if event and tool[event] then softassert( pcall( tool[event], tool ) ) end if tool.MouseReleased then softassert( pcall( tool.MouseReleased, tool, button ) ) end end end ) end)();
for i = 1, #__RUNLATER do local f = loadstring(__RUNLATER[i]) if f then pcall(f) end end
